# ğŸ“ Global Business Hub ì „ì²´ ì§€í‘œ ê³„ì‚° ëª…ì„¸ì„œ

> **ë¬¸ì„œ ë²„ì „**: 1.0  
> **ì‘ì„±ì¼**: 2024-12-19  
> **ëª©ì **: 1~30ì°¨ ì§€í‘œì˜ êµ¬ì²´ì ì¸ ê³„ì‚° ê³¼ì • ëª…ì„¸

---

## 1ì°¨ ì§€í‘œ: Raw / Primary Metrics

### P01: Total GMV (ì´ ê±°ë˜ì•¡)

```sql
-- ê³„ì‚° ì¿¼ë¦¬
SELECT 
  SUM(total_gmv_krw) as total_gmv,
  COUNT(DISTINCT order_code) as order_count,
  DATE_TRUNC('day', order_created) as date
FROM orders
WHERE order_created BETWEEN :start_date AND :end_date
GROUP BY DATE_TRUNC('day', order_created)
ORDER BY date
```

```typescript
// TypeScript ê³„ì‚°
function calculateTotalGMV(orders: Order[], startDate: Date, endDate: Date): number {
  return orders
    .filter(o => o.orderCreated >= startDate && o.orderCreated <= endDate)
    .reduce((sum, o) => sum + o.totalGmvKrw, 0);
}
```

| íŒŒë¼ë¯¸í„° | íƒ€ì… | ì„¤ëª… |
|---------|------|------|
| `start_date` | Date | ì¡°íšŒ ì‹œì‘ì¼ |
| `end_date` | Date | ì¡°íšŒ ì¢…ë£Œì¼ |
| **ë°˜í™˜ê°’** | Number | ì´ GMV (KRW) |

---

### P02: ì£¼ë¬¸ ê±´ìˆ˜

```typescript
function calculateOrderCount(orders: Order[], startDate: Date, endDate: Date): number {
  return orders
    .filter(o => o.orderCreated >= startDate && o.orderCreated <= endDate)
    .length;
}
```

---

### P03: í‰ê·  ì£¼ë¬¸ ê¸ˆì•¡ (AOV)

```typescript
function calculateAOV(orders: Order[], startDate: Date, endDate: Date): number {
  const filteredOrders = orders.filter(
    o => o.orderCreated >= startDate && o.orderCreated <= endDate
  );
  const totalGMV = filteredOrders.reduce((sum, o) => sum + o.totalGmvKrw, 0);
  return filteredOrders.length > 0 ? totalGMV / filteredOrders.length : 0;
}
```

**ìˆ˜ì‹**: `AOV = P01 / P02 = Total GMV / ì£¼ë¬¸ ê±´ìˆ˜`

---

### P14: ì´ ë¦¬ë·° ìˆ˜

```sql
SELECT COUNT(review_id) as total_reviews
FROM reviews
WHERE dt BETWEEN :start_date AND :end_date
```

---

### P15: í‰ê·  í‰ì 

```typescript
function calculateAvgRating(reviews: Review[], startDate: Date, endDate: Date): number {
  const filtered = reviews.filter(r => r.dt >= startDate && r.dt <= endDate);
  return filtered.length > 0 
    ? filtered.reduce((sum, r) => sum + r.rating, 0) / filtered.length 
    : 0;
}
```

---

### P16: NPS ì ìˆ˜

```typescript
function calculateNPS(reviews: Review[], startDate: Date, endDate: Date): NPSResult {
  const filtered = reviews.filter(r => r.dt >= startDate && r.dt <= endDate);
  const total = filtered.length;
  
  if (total === 0) return { nps: 0, promoters: 0, passives: 0, detractors: 0 };
  
  // 10ì  ë§Œì  ê¸°ì¤€: Promoter(9-10), Passive(7-8), Detractor(1-6)
  const promoters = filtered.filter(r => r.rating >= 9).length;
  const passives = filtered.filter(r => r.rating >= 7 && r.rating <= 8).length;
  const detractors = filtered.filter(r => r.rating <= 6).length;
  
  const nps = Math.round(((promoters - detractors) / total) * 100);
  
  return {
    nps,
    promoters,
    passives,
    detractors,
    promoterRate: (promoters / total) * 100,
    passiveRate: (passives / total) * 100,
    detractorRate: (detractors / total) * 100,
  };
}
```

**ìˆ˜ì‹**: `NPS = ((Promoters - Detractors) / Total) Ã— 100`

---

## 2ì°¨ ì§€í‘œ: Cross-Entity Derived

### D01: ê³ ê°ë³„ ì´ êµ¬ë§¤ì•¡

```sql
SELECT 
  user_id,
  SUM(total_gmv_krw) as total_spent,
  COUNT(DISTINCT order_code) as order_count,
  AVG(total_gmv_krw) as avg_order_value,
  MIN(order_created) as first_order,
  MAX(order_created) as last_order
FROM orders
GROUP BY user_id
```

---

### D03: RFM ì ìˆ˜

```typescript
interface RFMScore {
  userId: string;
  recency: number;      // ìµœê·¼ì„± (ì¼)
  frequency: number;    // ë¹ˆë„ (íšŒ)
  monetary: number;     // ê¸ˆì•¡ (ì›)
  rScore: number;       // R ì ìˆ˜ (1-5)
  fScore: number;       // F ì ìˆ˜ (1-5)
  mScore: number;       // M ì ìˆ˜ (1-5)
  rfmScore: number;     // ì¢…í•© ì ìˆ˜
  segment: string;      // ì„¸ê·¸ë¨¼íŠ¸ëª…
}

function calculateRFM(orders: Order[], today: Date): RFMScore[] {
  // 1. ê³ ê°ë³„ ì§‘ê³„
  const customerData = new Map<string, { orders: Order[] }>();
  orders.forEach(o => {
    if (!customerData.has(o.userId)) {
      customerData.set(o.userId, { orders: [] });
    }
    customerData.get(o.userId)!.orders.push(o);
  });
  
  // 2. RFM ê°’ ê³„ì‚°
  const rfmData: RFMScore[] = [];
  customerData.forEach((data, userId) => {
    const lastOrder = Math.max(...data.orders.map(o => o.orderCreated.getTime()));
    const recency = Math.floor((today.getTime() - lastOrder) / (1000 * 60 * 60 * 24));
    const frequency = data.orders.length;
    const monetary = data.orders.reduce((sum, o) => sum + o.totalGmvKrw, 0);
    
    rfmData.push({ userId, recency, frequency, monetary, rScore: 0, fScore: 0, mScore: 0, rfmScore: 0, segment: '' });
  });
  
  // 3. ë°±ë¶„ìœ„ ê¸°ë°˜ ì ìˆ˜í™” (Quintile)
  const recencyValues = rfmData.map(r => r.recency).sort((a, b) => a - b);
  const frequencyValues = rfmData.map(r => r.frequency).sort((a, b) => a - b);
  const monetaryValues = rfmData.map(r => r.monetary).sort((a, b) => a - b);
  
  function getQuintileScore(value: number, sortedArray: number[], reverse: boolean = false): number {
    const index = sortedArray.indexOf(value);
    const percentile = (index / sortedArray.length) * 100;
    const score = Math.ceil(percentile / 20) || 1;
    return reverse ? 6 - score : score; // RecencyëŠ” ì—­ìˆœ
  }
  
  rfmData.forEach(r => {
    r.rScore = getQuintileScore(r.recency, recencyValues, true);  // ì‘ì„ìˆ˜ë¡ ì¢‹ìŒ
    r.fScore = getQuintileScore(r.frequency, frequencyValues, false);
    r.mScore = getQuintileScore(r.monetary, monetaryValues, false);
    r.rfmScore = r.rScore * 100 + r.fScore * 10 + r.mScore;
    
    // 4. ì„¸ê·¸ë¨¼íŠ¸ ë¶„ë¥˜
    if (r.rScore >= 4 && r.fScore >= 4 && r.mScore >= 4) {
      r.segment = 'VIP ì¶©ì„±ê³ ê°';
    } else if (r.rScore >= 4 && r.fScore >= 3) {
      r.segment = 'í™œì„± ê³ ê°';
    } else if (r.rScore <= 2 && r.fScore >= 3) {
      r.segment = 'ì´íƒˆ ìœ„í—˜';
    } else if (r.rScore <= 2) {
      r.segment = 'íœ´ë©´ ê³ ê°';
    } else if (r.mScore >= 4 && r.fScore <= 2) {
      r.segment = 'ê³ ê°€ì¹˜ ì ì¬';
    } else {
      r.segment = 'ì¼ë°˜ ê³ ê°';
    }
  });
  
  return rfmData;
}
```

---

### D11: ì‘ê°€ë³„ í‰ê·  í‰ì 

```sql
SELECT 
  r.artist_id,
  r.artist_name,
  AVG(r.rating) as avg_rating,
  COUNT(r.review_id) as review_count,
  COUNT(CASE WHEN r.rating >= 9 THEN 1 END) as promoter_count,
  COUNT(CASE WHEN r.rating <= 6 THEN 1 END) as detractor_count,
  (COUNT(CASE WHEN r.rating >= 9 THEN 1 END) - COUNT(CASE WHEN r.rating <= 6 THEN 1 END)) * 100.0 / NULLIF(COUNT(*), 0) as nps
FROM reviews r
WHERE r.dt BETWEEN :start_date AND :end_date
GROUP BY r.artist_id, r.artist_name
ORDER BY avg_rating DESC
```

---

### D15: ì¬êµ¬ë§¤ìœ¨

```typescript
function calculateRepurchaseRate(orders: Order[]): RepurchaseMetrics {
  const customerOrders = new Map<string, number>();
  
  orders.forEach(o => {
    customerOrders.set(o.userId, (customerOrders.get(o.userId) || 0) + 1);
  });
  
  const totalCustomers = customerOrders.size;
  const repeatCustomers = Array.from(customerOrders.values()).filter(count => count > 1).length;
  
  return {
    totalCustomers,
    repeatCustomers,
    newCustomers: totalCustomers - repeatCustomers,
    repurchaseRate: totalCustomers > 0 ? (repeatCustomers / totalCustomers) * 100 : 0,
  };
}
```

**ìˆ˜ì‹**: `ì¬êµ¬ë§¤ìœ¨ = ì¬êµ¬ë§¤ ê³ ê° ìˆ˜ / ì „ì²´ ê³ ê° ìˆ˜ Ã— 100`

---

### D16: ì¿ í° ROI

```typescript
function calculateCouponROI(orders: Order[]): CouponROI {
  const ordersWithCoupon = orders.filter(o => o.couponDiscount > 0);
  const ordersWithoutCoupon = orders.filter(o => o.couponDiscount === 0);
  
  const totalCouponCost = ordersWithCoupon.reduce((sum, o) => sum + o.couponDiscount, 0);
  const totalCouponGMV = ordersWithCoupon.reduce((sum, o) => sum + o.totalGmvKrw, 0);
  const avgGMVWithoutCoupon = ordersWithoutCoupon.length > 0
    ? ordersWithoutCoupon.reduce((sum, o) => sum + o.totalGmvKrw, 0) / ordersWithoutCoupon.length
    : 0;
  
  // ì¿ í°ìœ¼ë¡œ ì¸í•œ ì¦ë¶„ GMV ì¶”ì •
  const incrementalGMV = totalCouponGMV - (avgGMVWithoutCoupon * ordersWithCoupon.length);
  
  const roi = totalCouponCost > 0 
    ? ((incrementalGMV - totalCouponCost) / totalCouponCost) * 100 
    : 0;
  
  return {
    totalCouponCost,
    totalCouponGMV,
    incrementalGMV,
    roi,
    usageRate: (ordersWithCoupon.length / orders.length) * 100,
    avgCouponDiscount: ordersWithCoupon.length > 0 ? totalCouponCost / ordersWithCoupon.length : 0,
  };
}
```

---

## 3ì°¨ ì§€í‘œ: Composite / Diagnostic

### C01: ê³ ê° ê±´ê°•ë„ ì ìˆ˜

```typescript
interface CustomerHealthScore {
  userId: string;
  score: number;           // 0-100
  grade: 'A' | 'B' | 'C' | 'D' | 'E';
  components: {
    rfmScore: number;      // ê°€ì¤‘ì¹˜ 0.4
    activityScore: number; // ê°€ì¤‘ì¹˜ 0.3
    engagementScore: number; // ê°€ì¤‘ì¹˜ 0.3
  };
  riskLevel: 'low' | 'medium' | 'high';
}

function calculateCustomerHealthScore(
  rfm: RFMScore,
  lastOrderDate: Date,
  reviewCount: number,
  avgRating: number,
  today: Date
): CustomerHealthScore {
  // 1. RFM ì ìˆ˜ ì •ê·œí™” (0-100)
  const rfmNormalized = ((rfm.rScore + rfm.fScore + rfm.mScore) / 15) * 100;
  
  // 2. í™œë™ ì ìˆ˜ (ìµœê·¼ í™œë™ ê¸°ì¤€)
  const daysSinceLastOrder = Math.floor((today.getTime() - lastOrderDate.getTime()) / (1000 * 60 * 60 * 24));
  let activityScore: number;
  if (daysSinceLastOrder <= 30) activityScore = 100;
  else if (daysSinceLastOrder <= 60) activityScore = 80;
  else if (daysSinceLastOrder <= 90) activityScore = 60;
  else if (daysSinceLastOrder <= 180) activityScore = 40;
  else activityScore = 20;
  
  // 3. ì°¸ì—¬ ì ìˆ˜ (ë¦¬ë·° + í‰ì )
  const reviewBonus = Math.min(reviewCount * 10, 50); // ìµœëŒ€ 50ì 
  const ratingBonus = avgRating > 0 ? (avgRating / 10) * 50 : 0; // ìµœëŒ€ 50ì 
  const engagementScore = reviewBonus + ratingBonus;
  
  // 4. ì¢…í•© ì ìˆ˜ ê³„ì‚° (ê°€ì¤‘ í‰ê· )
  const totalScore = (rfmNormalized * 0.4) + (activityScore * 0.3) + (engagementScore * 0.3);
  
  // 5. ë“±ê¸‰ ë° ë¦¬ìŠ¤í¬ ê²°ì •
  let grade: 'A' | 'B' | 'C' | 'D' | 'E';
  let riskLevel: 'low' | 'medium' | 'high';
  
  if (totalScore >= 80) { grade = 'A'; riskLevel = 'low'; }
  else if (totalScore >= 60) { grade = 'B'; riskLevel = 'low'; }
  else if (totalScore >= 40) { grade = 'C'; riskLevel = 'medium'; }
  else if (totalScore >= 20) { grade = 'D'; riskLevel = 'high'; }
  else { grade = 'E'; riskLevel = 'high'; }
  
  return {
    userId: rfm.userId,
    score: Math.round(totalScore),
    grade,
    components: {
      rfmScore: rfmNormalized,
      activityScore,
      engagementScore,
    },
    riskLevel,
  };
}
```

---

### C04: ê³ ê° LTV (Lifetime Value)

```typescript
interface CustomerLTV {
  userId: string;
  ltv: number;              // ì˜ˆìƒ LTV (KRW)
  historicalValue: number;  // ê³¼ê±° ì‹¤ì œ ê°€ì¹˜
  predictedValue: number;   // ì˜ˆì¸¡ ë¯¸ë˜ ê°€ì¹˜
  avgPurchaseCycle: number; // í‰ê·  êµ¬ë§¤ ì£¼ê¸° (ì¼)
  expectedLifetime: number; // ì˜ˆìƒ ê³ ê° ìˆ˜ëª… (ì›”)
  confidence: number;       // ì˜ˆì¸¡ ì‹ ë¢°ë„
}

function calculateCustomerLTV(
  orders: Order[],
  churnProbability: number,  // C02ì—ì„œ ê³„ì‚°
  avgCustomerLifetime: number = 24 // ê¸°ë³¸ 24ê°œì›”
): CustomerLTV {
  if (orders.length === 0) {
    return { userId: '', ltv: 0, historicalValue: 0, predictedValue: 0, avgPurchaseCycle: 0, expectedLifetime: 0, confidence: 0 };
  }
  
  // 1. ê³¼ê±° ì‹¤ì œ ê°€ì¹˜
  const historicalValue = orders.reduce((sum, o) => sum + o.totalGmvKrw, 0);
  
  // 2. í‰ê·  ì£¼ë¬¸ ê¸ˆì•¡ (AOV)
  const aov = historicalValue / orders.length;
  
  // 3. í‰ê·  êµ¬ë§¤ ì£¼ê¸° ê³„ì‚°
  const sortedOrders = orders.sort((a, b) => a.orderCreated.getTime() - b.orderCreated.getTime());
  let totalIntervalDays = 0;
  for (let i = 1; i < sortedOrders.length; i++) {
    totalIntervalDays += Math.floor(
      (sortedOrders[i].orderCreated.getTime() - sortedOrders[i-1].orderCreated.getTime()) / (1000 * 60 * 60 * 24)
    );
  }
  const avgPurchaseCycle = orders.length > 1 ? totalIntervalDays / (orders.length - 1) : 90;
  
  // 4. ì›”ê°„ êµ¬ë§¤ ë¹ˆë„
  const monthlyFrequency = 30 / avgPurchaseCycle;
  
  // 5. ì˜ˆìƒ ê³ ê° ìˆ˜ëª… (ì´íƒˆ í™•ë¥  ë°˜ì˜)
  const expectedLifetime = avgCustomerLifetime * (1 - churnProbability);
  
  // 6. ì˜ˆì¸¡ ë¯¸ë˜ ê°€ì¹˜
  const predictedValue = aov * monthlyFrequency * expectedLifetime;
  
  // 7. ì´ LTV
  const ltv = historicalValue + predictedValue;
  
  // 8. ì‹ ë¢°ë„ (ë°ì´í„° ì–‘ ê¸°ë°˜)
  const confidence = Math.min(orders.length / 10, 1); // 10íšŒ ì´ìƒ êµ¬ë§¤ ì‹œ 100%
  
  return {
    userId: orders[0].userId,
    ltv: Math.round(ltv),
    historicalValue: Math.round(historicalValue),
    predictedValue: Math.round(predictedValue),
    avgPurchaseCycle: Math.round(avgPurchaseCycle),
    expectedLifetime: Math.round(expectedLifetime),
    confidence,
  };
}
```

**ìˆ˜ì‹**: `LTV = Historical Value + (AOV Ã— Monthly Frequency Ã— Expected Lifetime Ã— (1 - Churn Probability))`

---

### C05: ì‘ê°€ ê±´ê°•ë„ ì ìˆ˜

```typescript
interface ArtistHealthScore {
  artistId: string;
  score: number;           // 0-100
  grade: 'S' | 'A' | 'B' | 'C' | 'D';
  components: {
    gmvScore: number;      // ê°€ì¤‘ì¹˜ 0.3
    orderScore: number;    // ê°€ì¤‘ì¹˜ 0.2
    qualityScore: number;  // ê°€ì¤‘ì¹˜ 0.3
    qcScore: number;       // ê°€ì¤‘ì¹˜ 0.2
  };
  trend: 'growing' | 'stable' | 'declining';
}

function calculateArtistHealthScore(
  artistId: string,
  gmv: number,
  orderCount: number,
  avgRating: number,
  qcPassRate: number,
  allArtistsGMV: number[],
  allArtistsOrders: number[]
): ArtistHealthScore {
  // 1. GMV ì ìˆ˜ (ë°±ë¶„ìœ„ ê¸°ë°˜)
  const gmvPercentile = calculatePercentile(gmv, allArtistsGMV);
  const gmvScore = gmvPercentile;
  
  // 2. ì£¼ë¬¸ ìˆ˜ ì ìˆ˜ (ë°±ë¶„ìœ„ ê¸°ë°˜)
  const orderPercentile = calculatePercentile(orderCount, allArtistsOrders);
  const orderScore = orderPercentile;
  
  // 3. í’ˆì§ˆ ì ìˆ˜ (í‰ì  ê¸°ë°˜, 10ì  ë§Œì )
  const qualityScore = (avgRating / 10) * 100;
  
  // 4. QC ì ìˆ˜ (ê²€ìˆ˜ í†µê³¼ìœ¨)
  const qcScore = qcPassRate * 100;
  
  // 5. ì¢…í•© ì ìˆ˜ ê³„ì‚°
  const totalScore = (gmvScore * 0.3) + (orderScore * 0.2) + (qualityScore * 0.3) + (qcScore * 0.2);
  
  // 6. ë“±ê¸‰ ê²°ì •
  let grade: 'S' | 'A' | 'B' | 'C' | 'D';
  if (totalScore >= 90) grade = 'S';
  else if (totalScore >= 70) grade = 'A';
  else if (totalScore >= 50) grade = 'B';
  else if (totalScore >= 30) grade = 'C';
  else grade = 'D';
  
  return {
    artistId,
    score: Math.round(totalScore),
    grade,
    components: { gmvScore, orderScore, qualityScore, qcScore },
    trend: 'stable', // ë³„ë„ ì‹œê³„ì—´ ë¶„ì„ í•„ìš”
  };
}

function calculatePercentile(value: number, allValues: number[]): number {
  const sorted = [...allValues].sort((a, b) => a - b);
  const index = sorted.findIndex(v => v >= value);
  return index >= 0 ? (index / sorted.length) * 100 : 100;
}
```

---

## 4ì°¨ ì§€í‘œ: Time-series / Comparative

### T01: GMV ì„±ì¥ë¥  (MoM)

```typescript
function calculateGMVGrowthMoM(
  currentMonthGMV: number,
  previousMonthGMV: number
): GrowthMetrics {
  const absoluteChange = currentMonthGMV - previousMonthGMV;
  const percentageChange = previousMonthGMV > 0 
    ? ((currentMonthGMV - previousMonthGMV) / previousMonthGMV) * 100 
    : 0;
  
  return {
    currentValue: currentMonthGMV,
    previousValue: previousMonthGMV,
    absoluteChange,
    percentageChange,
    trend: percentageChange > 0 ? 'up' : percentageChange < 0 ? 'down' : 'stable',
    interpretation: `ì „ì›” ëŒ€ë¹„ ${percentageChange > 0 ? '+' : ''}${percentageChange.toFixed(1)}% ${percentageChange >= 0 ? 'ì„±ì¥' : 'ê°ì†Œ'}`,
  };
}
```

**ìˆ˜ì‹**: `MoM Growth Rate = (Current Month - Previous Month) / Previous Month Ã— 100`

---

### T06: ì½”í˜¸íŠ¸ë³„ ì¬êµ¬ë§¤ìœ¨

```typescript
interface CohortAnalysis {
  cohortMonth: string;        // ê°€ì… ì›” (YYYY-MM)
  totalCustomers: number;     // ì½”í˜¸íŠ¸ ì´ ê³ ê° ìˆ˜
  retention: {
    month1: number;           // 1ê°œì›” í›„ ì¬êµ¬ë§¤ìœ¨
    month2: number;           // 2ê°œì›” í›„ ì¬êµ¬ë§¤ìœ¨
    month3: number;           // 3ê°œì›” í›„ ì¬êµ¬ë§¤ìœ¨
    month6: number;           // 6ê°œì›” í›„ ì¬êµ¬ë§¤ìœ¨
    month12: number;          // 12ê°œì›” í›„ ì¬êµ¬ë§¤ìœ¨
  };
}

function calculateCohortRetention(
  users: User[],
  orders: Order[]
): CohortAnalysis[] {
  // 1. ì½”í˜¸íŠ¸ë³„ ê·¸ë£¹í™” (ê°€ì…ì›” ê¸°ì¤€)
  const cohorts = new Map<string, Set<string>>();
  users.forEach(u => {
    const cohortMonth = u.createdAt.toISOString().slice(0, 7); // YYYY-MM
    if (!cohorts.has(cohortMonth)) {
      cohorts.set(cohortMonth, new Set());
    }
    cohorts.get(cohortMonth)!.add(u.id);
  });
  
  // 2. ê° ì½”í˜¸íŠ¸ì˜ ì›”ë³„ ì¬êµ¬ë§¤ìœ¨ ê³„ì‚°
  const results: CohortAnalysis[] = [];
  
  cohorts.forEach((userIds, cohortMonth) => {
    const cohortUsers = Array.from(userIds);
    const cohortStartDate = new Date(cohortMonth + '-01');
    
    // ê° ê¸°ê°„ë³„ êµ¬ë§¤ ê³ ê° ìˆ˜ ê³„ì‚°
    const retention = {
      month1: calculateRetentionForPeriod(cohortUsers, orders, cohortStartDate, 1),
      month2: calculateRetentionForPeriod(cohortUsers, orders, cohortStartDate, 2),
      month3: calculateRetentionForPeriod(cohortUsers, orders, cohortStartDate, 3),
      month6: calculateRetentionForPeriod(cohortUsers, orders, cohortStartDate, 6),
      month12: calculateRetentionForPeriod(cohortUsers, orders, cohortStartDate, 12),
    };
    
    results.push({
      cohortMonth,
      totalCustomers: cohortUsers.length,
      retention,
    });
  });
  
  return results.sort((a, b) => a.cohortMonth.localeCompare(b.cohortMonth));
}

function calculateRetentionForPeriod(
  userIds: string[],
  orders: Order[],
  cohortStartDate: Date,
  monthsAfter: number
): number {
  const periodStart = new Date(cohortStartDate);
  periodStart.setMonth(periodStart.getMonth() + monthsAfter);
  const periodEnd = new Date(periodStart);
  periodEnd.setMonth(periodEnd.getMonth() + 1);
  
  const purchasingUsers = new Set(
    orders
      .filter(o => 
        userIds.includes(o.userId) &&
        o.orderCreated >= periodStart &&
        o.orderCreated < periodEnd
      )
      .map(o => o.userId)
  );
  
  return userIds.length > 0 ? (purchasingUsers.size / userIds.length) * 100 : 0;
}
```

---

## 5ì°¨ ì§€í‘œ: Predictive / Scenario

### F01: GMV ì˜ˆì¸¡ (Next Month)

```typescript
import { Prophet } from 'prophet'; // ë˜ëŠ” ARIMA ë¼ì´ë¸ŒëŸ¬ë¦¬

interface GMVForecast {
  forecastDate: Date;
  predictedGMV: number;
  confidenceInterval: {
    lower: number;
    upper: number;
  };
  confidence: number;
}

function forecastGMV(
  historicalGMV: { date: Date; gmv: number }[],
  forecastPeriods: number = 30
): GMVForecast[] {
  // 1. ë°ì´í„° ì¤€ë¹„
  const df = historicalGMV.map(d => ({
    ds: d.date,
    y: d.gmv,
  }));
  
  // 2. Prophet ëª¨ë¸ í•™ìŠµ
  const model = new Prophet({
    yearly_seasonality: true,
    weekly_seasonality: true,
    daily_seasonality: false,
  });
  model.fit(df);
  
  // 3. ë¯¸ë˜ ì˜ˆì¸¡
  const future = model.make_future_dataframe({ periods: forecastPeriods });
  const forecast = model.predict(future);
  
  // 4. ê²°ê³¼ í¬ë§·íŒ…
  return forecast.slice(-forecastPeriods).map(row => ({
    forecastDate: new Date(row.ds),
    predictedGMV: Math.round(row.yhat),
    confidenceInterval: {
      lower: Math.round(row.yhat_lower),
      upper: Math.round(row.yhat_upper),
    },
    confidence: 0.95, // 95% ì‹ ë¢°êµ¬ê°„
  }));
}
```

---

### F02: ê³ ê° ì´íƒˆ ì˜ˆì¸¡

```typescript
interface ChurnPrediction {
  userId: string;
  churnProbability: number;  // 0-1
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  keyFactors: string[];
  recommendedAction: string;
}

function predictChurn(
  customerFeatures: CustomerFeatures
): ChurnPrediction {
  // íŠ¹ì„± ì—”ì§€ë‹ˆì–´ë§
  const features = {
    daysSinceLastOrder: customerFeatures.daysSinceLastOrder,
    orderFrequencyDecline: customerFeatures.recentFrequency / customerFeatures.historicalFrequency,
    avgRatingDecline: customerFeatures.recentAvgRating - customerFeatures.historicalAvgRating,
    csContactCount: customerFeatures.csContactCount,
    returnRate: customerFeatures.returnCount / customerFeatures.orderCount,
    couponDependency: customerFeatures.couponOrders / customerFeatures.totalOrders,
  };
  
  // ê°„ë‹¨í•œ ê·œì¹™ ê¸°ë°˜ ëª¨ë¸ (ì‹¤ì œë¡œëŠ” ML ëª¨ë¸ ì‚¬ìš©)
  let churnScore = 0;
  const keyFactors: string[] = [];
  
  // 1. ìµœê·¼ í™œë™ ë¶€ì¬
  if (features.daysSinceLastOrder > 90) {
    churnScore += 0.3;
    keyFactors.push('90ì¼ ì´ìƒ ë¯¸êµ¬ë§¤');
  } else if (features.daysSinceLastOrder > 60) {
    churnScore += 0.15;
    keyFactors.push('60ì¼ ì´ìƒ ë¯¸êµ¬ë§¤');
  }
  
  // 2. êµ¬ë§¤ ë¹ˆë„ ê°ì†Œ
  if (features.orderFrequencyDecline < 0.5) {
    churnScore += 0.25;
    keyFactors.push('êµ¬ë§¤ ë¹ˆë„ 50% ì´ìƒ ê°ì†Œ');
  }
  
  // 3. í‰ì  í•˜ë½
  if (features.avgRatingDecline < -2) {
    churnScore += 0.15;
    keyFactors.push('í‰ì  í•˜ë½');
  }
  
  // 4. CS ë¬¸ì˜ ì¦ê°€
  if (features.csContactCount > 3) {
    churnScore += 0.15;
    keyFactors.push('CS ë¬¸ì˜ ë‹¤ìˆ˜');
  }
  
  // 5. ë°˜í’ˆìœ¨ ë†’ìŒ
  if (features.returnRate > 0.2) {
    churnScore += 0.1;
    keyFactors.push('ë°˜í’ˆìœ¨ ë†’ìŒ');
  }
  
  const churnProbability = Math.min(churnScore, 1);
  
  // ë¦¬ìŠ¤í¬ ë ˆë²¨ ê²°ì •
  let riskLevel: 'low' | 'medium' | 'high' | 'critical';
  let recommendedAction: string;
  
  if (churnProbability >= 0.8) {
    riskLevel = 'critical';
    recommendedAction = 'ì¦‰ì‹œ ê°œì¸í™” ìœˆë°± ìº í˜ì¸ ë°œì†¡';
  } else if (churnProbability >= 0.6) {
    riskLevel = 'high';
    recommendedAction = 'íŠ¹ë³„ í• ì¸ ì¿ í° ë°œì†¡';
  } else if (churnProbability >= 0.4) {
    riskLevel = 'medium';
    recommendedAction = 'ë¦¬ë§ˆì¸ë“œ ì´ë©”ì¼ ë°œì†¡';
  } else {
    riskLevel = 'low';
    recommendedAction = 'ì •ê¸° ë‰´ìŠ¤ë ˆí„° ìœ ì§€';
  }
  
  return {
    userId: customerFeatures.userId,
    churnProbability,
    riskLevel,
    keyFactors,
    recommendedAction,
  };
}
```

---

## 6ì°¨ ì§€í‘œ: Multi-Dimensional Composite

### M01: ë¹„ì¦ˆë‹ˆìŠ¤ ê±´ê°•ë„

```typescript
interface BusinessHealthScore {
  totalScore: number;        // 0-100
  grade: 'Excellent' | 'Good' | 'Fair' | 'Poor' | 'Critical';
  dimensions: {
    customer: { score: number; weight: 0.25 };
    artist: { score: number; weight: 0.25 };
    logistics: { score: number; weight: 0.20 };
    revenue: { score: number; weight: 0.30 };
  };
  trend: 'improving' | 'stable' | 'declining';
  alerts: string[];
}

function calculateBusinessHealthScore(
  customerHealthAvg: number,   // C01 í‰ê· 
  artistHealthAvg: number,     // C05 í‰ê· 
  logisticsEfficiency: number, // C08
  revenueGrowth: number        // T01
): BusinessHealthScore {
  // 1. ê° ì°¨ì› ì ìˆ˜ ì •ê·œí™” (0-100)
  const customerScore = customerHealthAvg;
  const artistScore = artistHealthAvg;
  const logisticsScore = logisticsEfficiency;
  
  // ë§¤ì¶œ ì„±ì¥ë¥ ì„ ì ìˆ˜ë¡œ ë³€í™˜ (-20%~+20% â†’ 0~100)
  const revenueScore = Math.max(0, Math.min(100, 50 + (revenueGrowth * 2.5)));
  
  // 2. ê°€ì¤‘ í‰ê·  ê³„ì‚°
  const totalScore = 
    (customerScore * 0.25) +
    (artistScore * 0.25) +
    (logisticsScore * 0.20) +
    (revenueScore * 0.30);
  
  // 3. ë“±ê¸‰ ê²°ì •
  let grade: 'Excellent' | 'Good' | 'Fair' | 'Poor' | 'Critical';
  if (totalScore >= 85) grade = 'Excellent';
  else if (totalScore >= 70) grade = 'Good';
  else if (totalScore >= 50) grade = 'Fair';
  else if (totalScore >= 30) grade = 'Poor';
  else grade = 'Critical';
  
  // 4. ì•Œë¦¼ ìƒì„±
  const alerts: string[] = [];
  if (customerScore < 50) alerts.push('âš ï¸ ê³ ê° ê±´ê°•ë„ ì£¼ì˜');
  if (artistScore < 50) alerts.push('âš ï¸ ì‘ê°€ ê±´ê°•ë„ ì£¼ì˜');
  if (logisticsScore < 50) alerts.push('âš ï¸ ë¬¼ë¥˜ íš¨ìœ¨ ì£¼ì˜');
  if (revenueScore < 40) alerts.push('ğŸ”´ ë§¤ì¶œ ì„±ì¥ ìœ„í—˜');
  
  return {
    totalScore: Math.round(totalScore),
    grade,
    dimensions: {
      customer: { score: customerScore, weight: 0.25 },
      artist: { score: artistScore, weight: 0.25 },
      logistics: { score: logisticsScore, weight: 0.20 },
      revenue: { score: revenueScore, weight: 0.30 },
    },
    trend: revenueGrowth > 5 ? 'improving' : revenueGrowth < -5 ? 'declining' : 'stable',
    alerts,
  };
}
```

---

## ê³ ê¸‰ ì§€í‘œ ê³„ì‚° ì˜ˆì‹œ (11ì°¨ ì´ìƒ)

### CA01: ì¸ê³¼ê´€ê³„ ë¶„ì„ (Propensity Score Matching)

```python
# Python êµ¬í˜„ (ë³µì¡í•œ í†µê³„ ë¶„ì„)
import pandas as pd
import numpy as np
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import NearestNeighbors

def calculate_causal_effect(df, treatment_col, outcome_col, confounders):
    """
    PSM ê¸°ë°˜ ì¸ê³¼íš¨ê³¼ ì¶”ì •
    
    Parameters:
    -----------
    df : DataFrame - ë°ì´í„°
    treatment_col : str - ì²˜ë¦¬ ë³€ìˆ˜ (ì˜ˆ: 'wrote_review')
    outcome_col : str - ê²°ê³¼ ë³€ìˆ˜ (ì˜ˆ: 'repurchased')
    confounders : list - êµë€ë³€ìˆ˜ ëª©ë¡
    
    Returns:
    --------
    dict : ATE, ì‹ ë¢°êµ¬ê°„, í•´ì„
    """
    # 1. Propensity Score ê³„ì‚°
    X = pd.get_dummies(df[confounders], drop_first=True)
    y = df[treatment_col]
    
    ps_model = LogisticRegression(max_iter=1000)
    ps_model.fit(X, y)
    df['propensity_score'] = ps_model.predict_proba(X)[:, 1]
    
    # 2. Matching
    treated = df[df[treatment_col] == 1]
    control = df[df[treatment_col] == 0]
    
    nn = NearestNeighbors(n_neighbors=1, metric='euclidean')
    nn.fit(control[['propensity_score']])
    distances, indices = nn.kneighbors(treated[['propensity_score']])
    
    matched_control = control.iloc[indices.flatten()]
    
    # 3. ATE ê³„ì‚°
    ate = treated[outcome_col].mean() - matched_control[outcome_col].mean()
    
    # 4. Bootstrap ì‹ ë¢°êµ¬ê°„
    bootstrap_ates = []
    for _ in range(1000):
        t_sample = treated.sample(frac=1, replace=True)
        c_indices = np.random.choice(len(matched_control), size=len(t_sample), replace=True)
        c_sample = matched_control.iloc[c_indices]
        bootstrap_ates.append(t_sample[outcome_col].mean() - c_sample[outcome_col].mean())
    
    ci_lower = np.percentile(bootstrap_ates, 2.5)
    ci_upper = np.percentile(bootstrap_ates, 97.5)
    
    # 5. í†µê³„ì  ìœ ì˜ì„±
    is_significant = (ci_lower > 0) or (ci_upper < 0)
    
    return {
        'ate': ate,
        'ci_lower': ci_lower,
        'ci_upper': ci_upper,
        'is_significant': is_significant,
        'interpretation': f"ì²˜ë¦¬ íš¨ê³¼: {ate:.3f} (95% CI: [{ci_lower:.3f}, {ci_upper:.3f}])",
        'action': "ìœ ì˜ë¯¸í•œ íš¨ê³¼" if is_significant else "íš¨ê³¼ ë¶ˆí™•ì‹¤"
    }
```

---

> **ë‹¤ìŒ ë¬¸ì„œ**: í˜ì´ì§€ë³„ í™œìš© ì ì¬ í‰ê°€ ë° ìš°ì„ ìˆœìœ„ ì„¤ì •

